import numpy as np
from scipy.interpolate import interp1d
from dataclasses import dataclass


@dataclass
class BaseTrajectoryCfg:
    """Base configuration for the trajectory generator."""
    point_distance: float = 0.05
    """The distance between two consecutive points of the trajectory. Default is 0.05."""
    position_offset: tuple[float, float] = (0.0, 0.0)
    """The offset to apply to the trajectory position. Default is (0.0, 0.0)."""
    angle_offset: float = 0.0
    """The offset to apply to the trajectory angle. Default is 0.0."""


class BaseTrajectory:
    """Base trajectory generator class.
    
    The base trajectory generator class is used to generate a trajectory and reparametrize it.
    It provides methods to generate a trajectory, apply an offset to the position and angle, and reparametrize
    the trajectory. The trajectory is generated by the generate_trajectory method which must be implemented by
    the child classes. To get a trajectory, the trajectory property must be accessed. When accessing the trajectory
    property, the trajectory is generated, the offset is applied, and the trajectory is reparametrized.
    """
    def __init__(self, cfg: BaseTrajectoryCfg) -> None:
        """Initialize the base trajectory generator.
        
        Args:
            cfg (BaseTrajectoryCfg): The configuration of the trajectory generator.
        """
        self._cfg = cfg
        self._trajectory = None
        self._trajectory_angle = None

    @property
    def trajectory(self) -> tuple[np.ndarray, np.ndarray]:
        """Return the trajectory and the tangent angle to the trajectory.

        The trajectory is generated, the offset is applied, and the trajectory is reparametrized.

        Returns:
            tuple[np.ndarray, np.ndarray]: The trajectory and the tangent angle to the trajectory.
        """
        if (self._trajectory is None) or (self._trajectory_angle is None):
            self.generate_trajectory()
            self.apply_trajectory_offset()
            self.reparametrize()
        return self._trajectory, self._trajectory_angle

    def generate_trajectory(self) -> np.ndarray:
        """Generate the trajectory.

        This method must be implemented by the child classes to generate the trajectory.
        """
        raise NotImplementedError

    def apply_trajectory_offset(self) -> np.ndarray:
        """Apply the offset to the trajectory position and angle.
        
        The offset is applied to the trajectory position and angle using the position_offset and angle_offset
        parameters from the configuration.
        
        Returns:
            np.ndarray: The offseted and rotated trajectory.
        """
        # Apply rotation then translation
        x, y = self._trajectory[:, 0], self._trajectory[:, 1]
        x_rot = x * np.cos(self._cfg.angle_offset) - y * np.sin(self._cfg.angle_offset)
        y_rot = x * np.sin(self._cfg.angle_offset) + y * np.cos(self._cfg.angle_offset)
        x_rot += self._cfg.position_offset[0]
        y_rot += self._cfg.position_offset[1]
        self._trajectory = np.stack((x_rot, y_rot), axis=1)

    def reparametrize(self) -> np.ndarray:
        """Reparametrize the trajectory.

        The trajectory is reparametrized by interpolating the trajectory and the tangent angle to the trajectory
        using the point_distance parameter from the configuration.

        Returns:
            np.ndarray: The reparametrized trajectory.
        """
        # Compute the cumulative distance along the trajectory
        s = np.cumsum(np.sqrt(np.sum(np.square(np.diff(self._trajectory, axis=0)), axis=1)))
        s = np.insert(s, 0, 0)
        # Compute the tangent angle to the trajectory
        dx = np.gradient(self._trajectory[:,0], s)
        dy = np.gradient(self._trajectory[:,1], s)
        self._trajectory_angle = np.arctan2(dy, dx)
        # Interpolate the trajectory
        x_interp = interp1d(s, self._trajectory[:,0], kind="linear")
        y_interp = interp1d(s, self._trajectory[:,1], kind="linear")
        num_points = int(s[-1] / self._cfg.point_distance)
        s_new = np.linspace(0, s[-1], num=num_points)
        x_new = x_interp(s_new)
        y_new = y_interp(s_new)
        self._trajectory = np.stack((x_new, y_new), axis=1)
        # Interpolate the angle
        cos_interp = interp1d(s, np.cos(self._trajectory_angle), kind="linear")
        sin_interp = interp1d(s, np.sin(self._trajectory_angle), kind="linear")
        self._trajectory_angle = np.arctan2(sin_interp(s_new), cos_interp(s_new))